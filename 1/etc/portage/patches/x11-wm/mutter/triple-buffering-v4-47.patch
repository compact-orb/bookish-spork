diff '--color=auto' -ur mutter-test/clutter/clutter/clutter-frame.c mutter-47.9/clutter/clutter/clutter-frame.c
--- mutter-test/clutter/clutter/clutter-frame.c	2025-07-21 18:02:06.564763912 +0800
+++ mutter-47.9/clutter/clutter/clutter-frame.c	2025-06-29 18:09:22.000000000 +0800
@@ -115,16 +115,3 @@
   frame->result = result;
   frame->has_result = TRUE;
 }
-
-void
-clutter_frame_set_hint (ClutterFrame     *frame,
-                        ClutterFrameHint  hint)
-{
-  frame->hints |= hint;
-}
-
-ClutterFrameHint
-clutter_frame_get_hints (ClutterFrame *frame)
-{
-  return frame->hints;
-}
diff '--color=auto' -ur mutter-test/clutter/clutter/clutter-frame-clock.c mutter-47.9/clutter/clutter/clutter-frame-clock.c
--- mutter-test/clutter/clutter/clutter-frame-clock.c	2025-07-21 18:02:06.564763912 +0800
+++ mutter-47.9/clutter/clutter/clutter-frame-clock.c	2025-06-29 18:09:22.000000000 +0800
@@ -42,15 +42,6 @@
 
 static guint signals[N_SIGNALS];
 
-typedef enum
-{
-  TRIPLE_BUFFERING_MODE_NEVER,
-  TRIPLE_BUFFERING_MODE_AUTO,
-  TRIPLE_BUFFERING_MODE_ALWAYS,
-} TripleBufferingMode;
-
-static TripleBufferingMode triple_buffering_mode = TRIPLE_BUFFERING_MODE_AUTO;
-
 #define SYNC_DELAY_FALLBACK_FRACTION 0.875f
 
 #define MINIMUM_REFRESH_RATE 30.f
@@ -79,10 +70,8 @@
   CLUTTER_FRAME_CLOCK_STATE_IDLE,
   CLUTTER_FRAME_CLOCK_STATE_SCHEDULED,
   CLUTTER_FRAME_CLOCK_STATE_SCHEDULED_NOW,
-  CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE,
-  CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED,
-  CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED_NOW,
-  CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_TWO,
+  CLUTTER_FRAME_CLOCK_STATE_DISPATCHING,
+  CLUTTER_FRAME_CLOCK_STATE_PENDING_PRESENTED,
 } ClutterFrameClockState;
 
 struct _ClutterFrameClock
@@ -103,7 +92,6 @@
   ClutterFrameClockMode mode;
 
   int64_t last_dispatch_time_us;
-  int64_t prev_last_dispatch_time_us;
   int64_t last_dispatch_lateness_us;
   int64_t last_presentation_time_us;
   int64_t next_update_time_us;
@@ -125,9 +113,6 @@
   int64_t vblank_duration_us;
   /* Last KMS buffer submission time. */
   int64_t last_flip_time_us;
-  int64_t prev_last_flip_time_us;
-
-  ClutterFrameHint last_flip_hints;
 
   /* Last time we promoted short-term maximum to long-term one */
   int64_t longterm_promotion_us;
@@ -264,6 +249,10 @@
 maybe_update_longterm_max_duration_us (ClutterFrameClock *frame_clock,
                                        ClutterFrameInfo  *frame_info)
 {
+  /* Do not update long-term max if there has been no measurement */
+  if (!frame_clock->shortterm_max_update_duration_us)
+    return;
+
   if ((frame_info->presentation_time - frame_clock->longterm_promotion_us) <
       G_USEC_PER_SEC)
     return;
@@ -290,12 +279,6 @@
 clutter_frame_clock_notify_presented (ClutterFrameClock *frame_clock,
                                       ClutterFrameInfo  *frame_info)
 {
-#ifdef CLUTTER_ENABLE_DEBUG
-  const char *debug_state =
-    frame_clock->state == CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_TWO ?
-    "Triple buffering" : "Double buffering";
-#endif
-
   COGL_TRACE_BEGIN_SCOPED (ClutterFrameClockNotifyPresented,
                            "Clutter::FrameClock::presented()");
   COGL_TRACE_DESCRIBE (ClutterFrameClockNotifyPresented,
@@ -385,54 +368,22 @@
 
   frame_clock->got_measurements_last_frame = FALSE;
 
-  if ((frame_info->cpu_time_before_buffer_swap_us != 0 &&
-       frame_info->has_valid_gpu_rendering_duration) ||
-      frame_clock->ever_got_measurements)
+  if (frame_info->cpu_time_before_buffer_swap_us != 0 &&
+      frame_info->has_valid_gpu_rendering_duration)
     {
       int64_t dispatch_to_swap_us, swap_to_rendering_done_us, swap_to_flip_us;
-      int64_t dispatch_time_us = 0, flip_time_us = 0;
 
-      switch (frame_clock->state)
-        {
-        case CLUTTER_FRAME_CLOCK_STATE_INIT:
-        case CLUTTER_FRAME_CLOCK_STATE_IDLE:
-        case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED:
-        case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED_NOW:
-          g_warn_if_reached ();
-          G_GNUC_FALLTHROUGH;
-        case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE:
-        case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED:
-        case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED_NOW:
-          dispatch_time_us = frame_clock->last_dispatch_time_us;
-          flip_time_us = frame_clock->last_flip_time_us;
-          break;
-        case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_TWO:
-          dispatch_time_us = frame_clock->prev_last_dispatch_time_us;
-          flip_time_us = frame_clock->prev_last_flip_time_us;
-          break;
-        }
-
-      if (frame_info->cpu_time_before_buffer_swap_us == 0)
-        {
-          /* User thread cursor-only updates with no "swap": we do know
-           * the combined time from dispatch to flip at least.
-           */
-          dispatch_to_swap_us = 0;
-          swap_to_flip_us = flip_time_us - dispatch_time_us;
-        }
-      else
-        {
-          dispatch_to_swap_us = frame_info->cpu_time_before_buffer_swap_us -
-                                dispatch_time_us;
-          swap_to_flip_us = flip_time_us -
-                            frame_info->cpu_time_before_buffer_swap_us;
-        }
+      dispatch_to_swap_us =
+        frame_info->cpu_time_before_buffer_swap_us -
+        frame_clock->last_dispatch_time_us;
       swap_to_rendering_done_us =
         frame_info->gpu_rendering_duration_ns / 1000;
+      swap_to_flip_us =
+        frame_clock->last_flip_time_us -
+        frame_info->cpu_time_before_buffer_swap_us;
 
       CLUTTER_NOTE (FRAME_TIMINGS,
-                    "%s: update2dispatch %ld µs, dispatch2swap %ld µs, swap2render %ld µs, swap2flip %ld µs",
-                    debug_state,
+                    "update2dispatch %ld µs, dispatch2swap %ld µs, swap2render %ld µs, swap2flip %ld µs",
                     frame_clock->last_dispatch_lateness_us,
                     dispatch_to_swap_us,
                     swap_to_rendering_done_us,
@@ -443,7 +394,7 @@
                MAX (swap_to_rendering_done_us, swap_to_flip_us) +
                frame_clock->deadline_evasion_us,
                frame_clock->shortterm_max_update_duration_us,
-               2 * frame_clock->refresh_interval_us);
+               frame_clock->refresh_interval_us);
 
       maybe_update_longterm_max_duration_us (frame_clock, frame_info);
 
@@ -452,8 +403,7 @@
     }
   else
     {
-      CLUTTER_NOTE (FRAME_TIMINGS, "%s: update2dispatch %ld µs",
-                    debug_state,
+      CLUTTER_NOTE (FRAME_TIMINGS, "update2dispatch %ld µs",
                     frame_clock->last_dispatch_lateness_us);
     }
 
@@ -471,22 +421,11 @@
     case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED_NOW:
       g_warn_if_reached ();
       break;
-    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE:
+    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHING:
+    case CLUTTER_FRAME_CLOCK_STATE_PENDING_PRESENTED:
       frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_IDLE;
       maybe_reschedule_update (frame_clock);
       break;
-    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED:
-      frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_SCHEDULED;
-      maybe_reschedule_update (frame_clock);
-      break;
-    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED_NOW:
-      frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_SCHEDULED_NOW;
-      maybe_reschedule_update (frame_clock);
-      break;
-    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_TWO:
-      frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE;
-      maybe_reschedule_update (frame_clock);
-      break;
     }
 }
 
@@ -504,37 +443,26 @@
     case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED_NOW:
       g_warn_if_reached ();
       break;
-    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE:
+    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHING:
+    case CLUTTER_FRAME_CLOCK_STATE_PENDING_PRESENTED:
       frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_IDLE;
       maybe_reschedule_update (frame_clock);
       break;
-    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED:
-      frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_SCHEDULED;
-      maybe_reschedule_update (frame_clock);
-      break;
-    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED_NOW:
-      frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_SCHEDULED_NOW;
-      maybe_reschedule_update (frame_clock);
-      break;
-    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_TWO:
-      frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE;
-      maybe_reschedule_update (frame_clock);
-      break;
     }
 }
 
-static gboolean
-clutter_frame_clock_compute_max_render_time_us (ClutterFrameClock *frame_clock,
-                                                int64_t           *max_render_time_us)
+static int64_t
+clutter_frame_clock_compute_max_render_time_us (ClutterFrameClock *frame_clock)
 {
   int64_t refresh_interval_us;
+  int64_t max_render_time_us;
 
   refresh_interval_us = frame_clock->refresh_interval_us;
 
   if (!frame_clock->ever_got_measurements ||
       G_UNLIKELY (clutter_paint_debug_flags &
                   CLUTTER_DEBUG_DISABLE_DYNAMIC_MAX_RENDER_TIME))
-    return FALSE;
+    return (int64_t) (refresh_interval_us * SYNC_DELAY_FALLBACK_FRACTION);
 
   /* Max render time shows how early the frame clock needs to be dispatched
    * to make it to the predicted next presentation time. It is an estimate of
@@ -548,15 +476,15 @@
    * - The duration of vertical blank.
    * - A constant to account for variations in the above estimates.
    */
-  *max_render_time_us =
+  max_render_time_us =
     MAX (frame_clock->longterm_max_update_duration_us,
          frame_clock->shortterm_max_update_duration_us) +
     frame_clock->vblank_duration_us +
     clutter_max_render_time_constant_us;
 
-  *max_render_time_us = CLAMP (*max_render_time_us, 0, 2 * refresh_interval_us);
+  max_render_time_us = CLAMP (max_render_time_us, 0, refresh_interval_us);
 
-  return TRUE;
+  return max_render_time_us;
 }
 
 static void
@@ -571,9 +499,7 @@
   int64_t min_render_time_allowed_us;
   int64_t max_render_time_allowed_us;
   int64_t next_presentation_time_us;
-  int64_t next_smooth_presentation_time_us = 0;
   int64_t next_update_time_us;
-  gboolean max_render_time_is_known;
 
   now_us = g_get_monotonic_time ();
 
@@ -593,13 +519,10 @@
     }
 
   min_render_time_allowed_us = refresh_interval_us / 2;
+  max_render_time_allowed_us =
+    clutter_frame_clock_compute_max_render_time_us (frame_clock);
 
-  max_render_time_is_known =
-    clutter_frame_clock_compute_max_render_time_us (frame_clock,
-                                                    &max_render_time_allowed_us);
-
-  if (max_render_time_is_known &&
-      min_render_time_allowed_us > max_render_time_allowed_us)
+  if (min_render_time_allowed_us > max_render_time_allowed_us)
     min_render_time_allowed_us = max_render_time_allowed_us;
 
   /*
@@ -620,29 +543,7 @@
    *
    */
   last_presentation_time_us = frame_clock->last_presentation_time_us;
-  switch (frame_clock->state)
-    {
-    case CLUTTER_FRAME_CLOCK_STATE_INIT:
-    case CLUTTER_FRAME_CLOCK_STATE_IDLE:
-    case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED:
-    case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED_NOW:
-      next_smooth_presentation_time_us = last_presentation_time_us +
-                                         refresh_interval_us;
-      break;
-    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE:
-    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED:
-    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED_NOW:
-      next_smooth_presentation_time_us = last_presentation_time_us +
-                                         2 * refresh_interval_us;
-      break;
-    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_TWO:
-      g_warn_if_reached ();  /* quad buffering would be a bug */
-      next_smooth_presentation_time_us = last_presentation_time_us +
-                                         3 * refresh_interval_us;
-      break;
-    }
-
-  next_presentation_time_us = next_smooth_presentation_time_us;
+  next_presentation_time_us = last_presentation_time_us + refresh_interval_us;
 
   /*
    * However, the last presentation could have happened more than a frame ago.
@@ -709,7 +610,7 @@
     }
 
   if (frame_clock->last_presentation_flags & CLUTTER_FRAME_INFO_FLAG_VSYNC &&
-      next_presentation_time_us != next_smooth_presentation_time_us)
+      next_presentation_time_us != last_presentation_time_us + refresh_interval_us)
     {
       /* There was an idle period since the last presentation, so there seems
        * be no constantly updating actor. In this case it's best to start
@@ -721,24 +622,6 @@
     }
   else
     {
-      /* If the max render time isn't known then using the current value of
-       * next_presentation_time_us is suboptimal. Targeting always one frame
-       * prior to that we'd lose the ability to scale up to triple buffering
-       * on late presentation. But targeting two frames prior we would be
-       * always triple buffering even when not required.
-       *   So the algorithm for deciding when to scale up to triple buffering
-       * in the absence of render time measurements is to simply target full
-       * frame rate. If we're keeping up then we'll stay double buffering. If
-       * we're not keeping up then this will switch us to triple buffering.
-       */
-      if (!max_render_time_is_known)
-        {
-          max_render_time_allowed_us =
-            (int64_t) (refresh_interval_us * SYNC_DELAY_FALLBACK_FRACTION);
-          next_presentation_time_us =
-            last_presentation_time_us + refresh_interval_us;
-        }
-
       while (next_presentation_time_us - min_render_time_allowed_us < now_us)
         next_presentation_time_us += refresh_interval_us;
 
@@ -770,9 +653,7 @@
 
   refresh_interval_us = frame_clock->refresh_interval_us;
 
-  if (frame_clock->last_presentation_time_us == 0 ||
-      !clutter_frame_clock_compute_max_render_time_us (frame_clock,
-                                                       &max_render_time_allowed_us))
+  if (frame_clock->last_presentation_time_us == 0)
     {
       *out_next_update_time_us =
         frame_clock->last_dispatch_time_us ?
@@ -785,6 +666,9 @@
       return;
     }
 
+  max_render_time_allowed_us =
+    clutter_frame_clock_compute_max_render_time_us (frame_clock);
+
   last_presentation_time_us = frame_clock->last_presentation_time_us;
   next_presentation_time_us = last_presentation_time_us + refresh_interval_us;
 
@@ -858,17 +742,8 @@
           frame_clock->pending_reschedule_now = TRUE;
           frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_IDLE;
           break;
-        case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED:
-          frame_clock->pending_reschedule = TRUE;
-          frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE;
-          break;
-        case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED_NOW:
-          frame_clock->pending_reschedule = TRUE;
-          frame_clock->pending_reschedule_now = TRUE;
-          frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE;
-          break;
-        case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE:
-        case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_TWO:
+        case CLUTTER_FRAME_CLOCK_STATE_DISPATCHING:
+        case CLUTTER_FRAME_CLOCK_STATE_PENDING_PRESENTED:
           break;
         }
 
@@ -887,25 +762,6 @@
     maybe_reschedule_update (frame_clock);
 }
 
-static gboolean
-want_triple_buffering (ClutterFrameClock *frame_clock)
-{
-  switch (triple_buffering_mode)
-    {
-    case TRIPLE_BUFFERING_MODE_NEVER:
-      return FALSE;
-    case TRIPLE_BUFFERING_MODE_AUTO:
-      return frame_clock->mode == CLUTTER_FRAME_CLOCK_MODE_FIXED &&
-             !(frame_clock->last_flip_hints &
-               CLUTTER_FRAME_HINT_DIRECT_SCANOUT_ATTEMPTED);
-    case TRIPLE_BUFFERING_MODE_ALWAYS:
-      return TRUE;
-    }
-
-  g_assert_not_reached ();
-  return FALSE;
-}
-
 void
 clutter_frame_clock_schedule_update_now (ClutterFrameClock *frame_clock)
 {
@@ -923,24 +779,11 @@
     case CLUTTER_FRAME_CLOCK_STATE_INIT:
     case CLUTTER_FRAME_CLOCK_STATE_IDLE:
     case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED:
-      frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_SCHEDULED_NOW;
       break;
     case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED_NOW:
-    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED_NOW:
       return;
-    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED:
-      frame_clock->state =
-        CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED_NOW;
-      break;
-    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE:
-      if (want_triple_buffering (frame_clock))
-        {
-          frame_clock->state =
-            CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED_NOW;
-          break;
-        }
-      G_GNUC_FALLTHROUGH;
-    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_TWO:
+    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHING:
+    case CLUTTER_FRAME_CLOCK_STATE_PENDING_PRESENTED:
       frame_clock->pending_reschedule = TRUE;
       frame_clock->pending_reschedule_now = TRUE;
       return;
@@ -969,17 +812,13 @@
 
   frame_clock->next_update_time_us = next_update_time_us;
   g_source_set_ready_time (frame_clock->source, next_update_time_us);
+  frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_SCHEDULED_NOW;
 }
 
 void
 clutter_frame_clock_schedule_update (ClutterFrameClock *frame_clock)
 {
   int64_t next_update_time_us = -1;
-  TripleBufferingMode current_mode = triple_buffering_mode;
-
-  if (current_mode == TRIPLE_BUFFERING_MODE_AUTO &&
-      !want_triple_buffering (frame_clock))
-    current_mode = TRIPLE_BUFFERING_MODE_NEVER;
 
   if (frame_clock->inhibit_count > 0)
     {
@@ -995,33 +834,12 @@
       frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_SCHEDULED;
       return;
     case CLUTTER_FRAME_CLOCK_STATE_IDLE:
-      frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_SCHEDULED;
       break;
     case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED:
     case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED_NOW:
-    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED:
-    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED_NOW:
       return;
-    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE:
-      switch (current_mode)
-        {
-        case TRIPLE_BUFFERING_MODE_NEVER:
-          frame_clock->pending_reschedule = TRUE;
-          return;
-        case TRIPLE_BUFFERING_MODE_AUTO:
-          frame_clock->state =
-            CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED;
-          break;
-        case TRIPLE_BUFFERING_MODE_ALWAYS:
-          next_update_time_us = g_get_monotonic_time ();
-          frame_clock->next_presentation_time_us = 0;
-          frame_clock->is_next_presentation_time_valid = FALSE;
-          frame_clock->state =
-            CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED;
-          goto got_update_time;
-        }
-      break;
-    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_TWO:
+    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHING:
+    case CLUTTER_FRAME_CLOCK_STATE_PENDING_PRESENTED:
       frame_clock->pending_reschedule = TRUE;
       return;
     }
@@ -1046,11 +864,11 @@
       break;
     }
 
-got_update_time:
   g_warn_if_fail (next_update_time_us != -1);
 
   frame_clock->next_update_time_us = next_update_time_us;
   g_source_set_ready_time (frame_clock->source, next_update_time_us);
+  frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_SCHEDULED;
 }
 
 void
@@ -1066,8 +884,6 @@
     {
     case CLUTTER_FRAME_CLOCK_STATE_INIT:
     case CLUTTER_FRAME_CLOCK_STATE_IDLE:
-    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE:
-    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_TWO:
       break;
     case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED:
       frame_clock->pending_reschedule = TRUE;
@@ -1078,14 +894,8 @@
       frame_clock->pending_reschedule_now = TRUE;
       frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_IDLE;
       break;
-    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED:
-      frame_clock->pending_reschedule = TRUE;
-      frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE;
-      break;
-    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED_NOW:
-      frame_clock->pending_reschedule = TRUE;
-      frame_clock->pending_reschedule_now = TRUE;
-      frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE;
+    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHING:
+    case CLUTTER_FRAME_CLOCK_STATE_PENDING_PRESENTED:
       break;
     }
 
@@ -1121,7 +931,7 @@
                              frame_clock->refresh_interval_us;
 
   lateness_us = time_us - ideal_dispatch_time_us;
-  if (lateness_us < 0 || lateness_us >= frame_clock->refresh_interval_us / 4)
+  if (lateness_us < 0 || lateness_us >= frame_clock->refresh_interval_us)
     frame_clock->last_dispatch_lateness_us = 0;
   else
     frame_clock->last_dispatch_lateness_us = lateness_us;
@@ -1142,27 +952,10 @@
     }
 #endif
 
-  frame_clock->prev_last_dispatch_time_us = frame_clock->last_dispatch_time_us;
   frame_clock->last_dispatch_time_us = time_us;
   g_source_set_ready_time (frame_clock->source, -1);
 
-  switch (frame_clock->state)
-    {
-    case CLUTTER_FRAME_CLOCK_STATE_INIT:
-    case CLUTTER_FRAME_CLOCK_STATE_IDLE:
-    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE:
-    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_TWO:
-      g_warn_if_reached ();
-      return;
-    case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED:
-    case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED_NOW:
-      frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE;
-      break;
-    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED:
-    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED_NOW:
-      frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_TWO;
-      break;
-    }
+  frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_DISPATCHING;
 
   frame_count = frame_clock->frame_count++;
 
@@ -1193,36 +986,26 @@
   result = iface->frame (frame_clock, frame, frame_clock->listener.user_data);
   COGL_TRACE_END (ClutterFrameClockFrame);
 
-  switch (result)
+  switch (frame_clock->state)
     {
-    case CLUTTER_FRAME_RESULT_PENDING_PRESENTED:
+    case CLUTTER_FRAME_CLOCK_STATE_INIT:
+    case CLUTTER_FRAME_CLOCK_STATE_PENDING_PRESENTED:
+      g_warn_if_reached ();
       break;
-    case CLUTTER_FRAME_RESULT_IDLE:
-      /* The frame was aborted; nothing to paint/present */
-      switch (frame_clock->state)
+    case CLUTTER_FRAME_CLOCK_STATE_IDLE:
+    case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED:
+    case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED_NOW:
+      break;
+    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHING:
+      switch (result)
         {
-        case CLUTTER_FRAME_CLOCK_STATE_INIT:
-        case CLUTTER_FRAME_CLOCK_STATE_IDLE:
-        case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED:
-        case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED_NOW:
-          g_warn_if_reached ();
+        case CLUTTER_FRAME_RESULT_PENDING_PRESENTED:
+          frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_PENDING_PRESENTED;
           break;
-        case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE:
+        case CLUTTER_FRAME_RESULT_IDLE:
           frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_IDLE;
           maybe_reschedule_update (frame_clock);
           break;
-        case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED:
-          frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_SCHEDULED;
-          maybe_reschedule_update (frame_clock);
-          break;
-        case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED_NOW:
-          frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_SCHEDULED_NOW;
-          maybe_reschedule_update (frame_clock);
-          break;
-        case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_TWO:
-          frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE;
-          maybe_reschedule_update (frame_clock);
-          break;
         }
       break;
     }
@@ -1255,31 +1038,21 @@
 }
 
 void
-clutter_frame_clock_record_flip (ClutterFrameClock *frame_clock,
-                                 int64_t            flip_time_us,
-                                 ClutterFrameHint   hints)
+clutter_frame_clock_record_flip_time (ClutterFrameClock *frame_clock,
+                                      int64_t            flip_time_us)
 {
-  frame_clock->prev_last_flip_time_us = frame_clock->last_flip_time_us;
   frame_clock->last_flip_time_us = flip_time_us;
-  frame_clock->last_flip_hints = hints;
 }
 
 GString *
 clutter_frame_clock_get_max_render_time_debug_info (ClutterFrameClock *frame_clock)
 {
-  int64_t max_render_time_us;
   int64_t max_update_duration_us;
   GString *string;
 
-  string = g_string_new ("Max render time: ");
-  if (!clutter_frame_clock_compute_max_render_time_us (frame_clock,
-                                                       &max_render_time_us))
-    {
-      g_string_append (string, "unknown");
-      return string;
-    }
-
-  g_string_append_printf (string, "%ld µs", max_render_time_us);
+  string = g_string_new (NULL);
+  g_string_append_printf (string, "Max render time: %ld µs",
+                          clutter_frame_clock_compute_max_render_time_us (frame_clock));
 
   if (frame_clock->got_measurements_last_frame)
     g_string_append_printf (string, " =");
@@ -1446,6 +1219,8 @@
 {
   ClutterFrameClock *frame_clock = CLUTTER_FRAME_CLOCK (object);
 
+  g_warn_if_fail (frame_clock->state != CLUTTER_FRAME_CLOCK_STATE_DISPATCHING);
+
   if (frame_clock->source)
     {
       g_signal_emit (frame_clock, signals[DESTROY], 0);
@@ -1469,15 +1244,6 @@
 clutter_frame_clock_class_init (ClutterFrameClockClass *klass)
 {
   GObjectClass *object_class = G_OBJECT_CLASS (klass);
-  const char *mode_str;
-
-  mode_str = g_getenv ("MUTTER_DEBUG_TRIPLE_BUFFERING");
-  if (!g_strcmp0 (mode_str, "never"))
-    triple_buffering_mode = TRIPLE_BUFFERING_MODE_NEVER;
-  else if (!g_strcmp0 (mode_str, "auto"))
-    triple_buffering_mode = TRIPLE_BUFFERING_MODE_AUTO;
-  else if (!g_strcmp0 (mode_str, "always"))
-    triple_buffering_mode = TRIPLE_BUFFERING_MODE_ALWAYS;
 
   object_class->dispose = clutter_frame_clock_dispose;
 
diff '--color=auto' -ur mutter-test/clutter/clutter/clutter-frame-clock.h mutter-47.9/clutter/clutter/clutter-frame-clock.h
--- mutter-test/clutter/clutter/clutter-frame-clock.h	2025-07-21 18:02:06.564763912 +0800
+++ mutter-47.9/clutter/clutter/clutter-frame-clock.h	2025-06-29 18:09:22.000000000 +0800
@@ -33,12 +33,6 @@
   CLUTTER_FRAME_RESULT_IDLE,
 } ClutterFrameResult;
 
-typedef enum _ClutterFrameHint
-{
-  CLUTTER_FRAME_HINT_NONE                     = 0,
-  CLUTTER_FRAME_HINT_DIRECT_SCANOUT_ATTEMPTED = 1 << 0,
-} ClutterFrameHint;
-
 #define CLUTTER_TYPE_FRAME_CLOCK (clutter_frame_clock_get_type ())
 CLUTTER_EXPORT
 G_DECLARE_FINAL_TYPE (ClutterFrameClock, clutter_frame_clock,
@@ -108,9 +102,8 @@
 CLUTTER_EXPORT
 float clutter_frame_clock_get_refresh_rate (ClutterFrameClock *frame_clock);
 
-void clutter_frame_clock_record_flip (ClutterFrameClock *frame_clock,
-                                      int64_t            flip_time_us,
-                                      ClutterFrameHint   hints);
+void clutter_frame_clock_record_flip_time (ClutterFrameClock *frame_clock,
+                                           int64_t            flip_time_us);
 
 GString * clutter_frame_clock_get_max_render_time_debug_info (ClutterFrameClock *frame_clock);
 
diff '--color=auto' -ur mutter-test/clutter/clutter/clutter-frame.h mutter-47.9/clutter/clutter/clutter-frame.h
--- mutter-test/clutter/clutter/clutter-frame.h	2025-07-21 18:02:06.564763912 +0800
+++ mutter-47.9/clutter/clutter/clutter-frame.h	2025-06-29 18:09:22.000000000 +0800
@@ -54,11 +54,4 @@
 CLUTTER_EXPORT
 gboolean clutter_frame_has_result (ClutterFrame *frame);
 
-CLUTTER_EXPORT
-void clutter_frame_set_hint (ClutterFrame     *frame,
-                             ClutterFrameHint  hint);
-
-CLUTTER_EXPORT
-ClutterFrameHint clutter_frame_get_hints (ClutterFrame *frame);
-
 G_DEFINE_AUTOPTR_CLEANUP_FUNC (ClutterFrame, clutter_frame_unref)
diff '--color=auto' -ur mutter-test/clutter/clutter/clutter-frame-private.h mutter-47.9/clutter/clutter/clutter-frame-private.h
--- mutter-test/clutter/clutter/clutter-frame-private.h	2025-07-21 18:02:06.564763912 +0800
+++ mutter-47.9/clutter/clutter/clutter-frame-private.h	2025-06-29 18:09:22.000000000 +0800
@@ -36,7 +36,6 @@
 
   gboolean has_result;
   ClutterFrameResult result;
-  ClutterFrameHint hints;
 };
 
 CLUTTER_EXPORT
diff '--color=auto' -ur mutter-test/clutter/clutter/clutter-stage-view.c mutter-47.9/clutter/clutter/clutter-stage-view.c
--- mutter-test/clutter/clutter/clutter-stage-view.c	2025-07-21 18:02:06.564763912 +0800
+++ mutter-47.9/clutter/clutter/clutter-stage-view.c	2025-06-29 18:09:22.000000000 +0800
@@ -1076,21 +1076,14 @@
 
       _clutter_stage_window_redraw_view (stage_window, view, frame);
 
-      clutter_frame_clock_record_flip (frame_clock,
-                                       g_get_monotonic_time (),
-                                       clutter_frame_get_hints (frame));
+      clutter_frame_clock_record_flip_time (frame_clock,
+                                            g_get_monotonic_time ());
 
       clutter_stage_emit_after_paint (stage, view, frame);
 
       if (clutter_context_get_show_fps (context))
         end_frame_timing_measurement (view);
     }
-  else
-    {
-      clutter_frame_clock_record_flip (frame_clock,
-                                       g_get_monotonic_time (),
-                                       clutter_frame_get_hints (frame));
-    }
 
   _clutter_stage_window_finish_frame (stage_window, view, frame);
 
diff '--color=auto' -ur mutter-test/cogl/cogl/cogl-onscreen.c mutter-47.9/cogl/cogl/cogl-onscreen.c
--- mutter-test/cogl/cogl/cogl-onscreen.c	2025-07-21 18:02:06.581430685 +0800
+++ mutter-47.9/cogl/cogl/cogl-onscreen.c	2025-06-29 18:09:22.000000000 +0800
@@ -466,14 +466,6 @@
   return g_queue_pop_head (&priv->pending_frame_infos);
 }
 
-unsigned int
-cogl_onscreen_get_pending_frame_count (CoglOnscreen *onscreen)
-{
-  CoglOnscreenPrivate *priv = cogl_onscreen_get_instance_private (onscreen);
-
-  return g_queue_get_length (&priv->pending_frame_infos);
-}
-
 CoglFrameClosure *
 cogl_onscreen_add_frame_callback (CoglOnscreen *onscreen,
                                   CoglFrameCallback callback,
diff '--color=auto' -ur mutter-test/cogl/cogl/cogl-onscreen-private.h mutter-47.9/cogl/cogl/cogl-onscreen-private.h
--- mutter-test/cogl/cogl/cogl-onscreen-private.h	2025-07-21 18:02:06.581430685 +0800
+++ mutter-47.9/cogl/cogl/cogl-onscreen-private.h	2025-06-29 18:09:22.000000000 +0800
@@ -79,7 +79,4 @@
 cogl_onscreen_peek_tail_frame_info (CoglOnscreen *onscreen);
 
 COGL_EXPORT CoglFrameInfo *
-cogl_onscreen_pop_head_frame_info  (CoglOnscreen *onscreen);
-
-COGL_EXPORT unsigned int
-cogl_onscreen_get_pending_frame_count (CoglOnscreen *onscreen);
+cogl_onscreen_pop_head_frame_info (CoglOnscreen *onscreen);
Only in mutter-47.9: .editorconfig
Only in mutter-47.9: .gitignore
Only in mutter-47.9: .gitlab
Only in mutter-47.9: .gitlab-ci
Only in mutter-47.9: .gitlab-ci.yml
diff '--color=auto' -ur mutter-test/src/backends/meta-stage-impl.c mutter-47.9/src/backends/meta-stage-impl.c
--- mutter-test/src/backends/meta-stage-impl.c	2025-07-21 18:02:06.618097583 +0800
+++ mutter-47.9/src/backends/meta-stage-impl.c	2025-06-29 18:09:22.000000000 +0800
@@ -801,8 +801,6 @@
     {
       g_autoptr (GError) error = NULL;
 
-      clutter_frame_set_hint (frame, CLUTTER_FRAME_HINT_DIRECT_SCANOUT_ATTEMPTED);
-
       if (meta_stage_impl_scanout_view (stage_impl,
                                         stage_view,
                                         scanout,
diff '--color=auto' -ur mutter-test/src/backends/native/meta-frame-native.c mutter-47.9/src/backends/native/meta-frame-native.c
--- mutter-test/src/backends/native/meta-frame-native.c	2025-07-21 18:02:06.611430874 +0800
+++ mutter-47.9/src/backends/native/meta-frame-native.c	2025-06-29 18:09:22.000000000 +0800
@@ -31,11 +31,6 @@
   CoglScanout *scanout;
 
   MetaKmsUpdate *kms_update;
-
-  struct {
-    int n_rectangles;
-    int *rectangles;  /* 4 x n_rectangles */
-  } damage;
 };
 
 static void
@@ -43,7 +38,6 @@
 {
   MetaFrameNative *frame_native = meta_frame_native_from_frame (frame);
 
-  g_clear_pointer (&frame_native->damage.rectangles, g_free);
   g_clear_object (&frame_native->buffer);
   g_clear_object (&frame_native->scanout);
 
@@ -114,28 +108,3 @@
 {
   return frame_native->scanout;
 }
-
-void
-meta_frame_native_set_damage (MetaFrameNative *frame_native,
-                              const int       *rectangles,
-                              int              n_rectangles)
-{
-  size_t rectangles_size;
-
-  rectangles_size = n_rectangles * 4 * sizeof (int);
-
-  frame_native->damage.rectangles =
-    g_realloc (frame_native->damage.rectangles, rectangles_size);
-  memcpy (frame_native->damage.rectangles, rectangles, rectangles_size);
-  frame_native->damage.n_rectangles = n_rectangles;
-}
-
-int
-meta_frame_native_get_damage (MetaFrameNative  *frame_native,
-                              int             **rectangles)
-{
-  if (rectangles)
-    *rectangles = frame_native->damage.rectangles;
-
-  return frame_native->damage.n_rectangles;
-}
diff '--color=auto' -ur mutter-test/src/backends/native/meta-frame-native.h mutter-47.9/src/backends/native/meta-frame-native.h
--- mutter-test/src/backends/native/meta-frame-native.h	2025-07-21 18:02:06.611430874 +0800
+++ mutter-47.9/src/backends/native/meta-frame-native.h	2025-06-29 18:09:22.000000000 +0800
@@ -47,12 +47,3 @@
                                     CoglScanout     *scanout);
 
 CoglScanout * meta_frame_native_get_scanout (MetaFrameNative *frame_native);
-
-void
-meta_frame_native_set_damage (MetaFrameNative *frame_native,
-                              const int       *rectangles,
-                              int              n_rectangles);
-
-int
-meta_frame_native_get_damage (MetaFrameNative  *frame_native,
-                              int             **rectangles);
diff '--color=auto' -ur mutter-test/src/backends/native/meta-kms.c mutter-47.9/src/backends/native/meta-kms.c
--- mutter-test/src/backends/native/meta-kms.c	2025-07-21 18:02:06.611430874 +0800
+++ mutter-47.9/src/backends/native/meta-kms.c	2025-06-29 18:09:22.000000000 +0800
@@ -66,8 +66,6 @@
   int kernel_thread_inhibit_count;
 
   MetaKmsCursorManager *cursor_manager;
-
-  gboolean shutting_down;
 };
 
 G_DEFINE_TYPE (MetaKms, meta_kms, META_TYPE_THREAD)
@@ -354,12 +352,6 @@
   return device;
 }
 
-gboolean
-meta_kms_is_shutting_down (MetaKms *kms)
-{
-  return kms->shutting_down;
-}
-
 static gpointer
 prepare_shutdown_in_impl (MetaThreadImpl  *thread_impl,
                           gpointer         user_data,
@@ -375,7 +367,6 @@
 on_prepare_shutdown (MetaBackend *backend,
                      MetaKms     *kms)
 {
-  kms->shutting_down = TRUE;
   meta_kms_run_impl_task_sync (kms, prepare_shutdown_in_impl, NULL, NULL);
   meta_thread_flush_callbacks (META_THREAD (kms));
 
diff '--color=auto' -ur mutter-test/src/backends/native/meta-kms.h mutter-47.9/src/backends/native/meta-kms.h
--- mutter-test/src/backends/native/meta-kms.h	2025-07-21 18:02:06.611430874 +0800
+++ mutter-47.9/src/backends/native/meta-kms.h	2025-06-29 18:09:22.000000000 +0800
@@ -61,8 +61,6 @@
                                         MetaKmsDeviceFlag   flags,
                                         GError            **error);
 
-gboolean meta_kms_is_shutting_down (MetaKms *kms);
-
 MetaKms * meta_kms_new (MetaBackend   *backend,
                         MetaKmsFlags   flags,
                         GError       **error);
diff '--color=auto' -ur mutter-test/src/backends/native/meta-onscreen-native.c mutter-47.9/src/backends/native/meta-onscreen-native.c
--- mutter-test/src/backends/native/meta-onscreen-native.c	2025-07-21 18:02:06.611430874 +0800
+++ mutter-47.9/src/backends/native/meta-onscreen-native.c	2025-06-29 18:09:22.000000000 +0800
@@ -78,7 +78,7 @@
 
   struct {
     MetaDrmBufferDumb *current_dumb_fb;
-    MetaDrmBufferDumb *dumb_fbs[3];
+    MetaDrmBufferDumb *dumb_fbs[2];
   } cpu;
 
   gboolean noted_primary_gpu_copy_ok;
@@ -103,11 +103,8 @@
   MetaCrtc *crtc;
 
   MetaOnscreenNativeSecondaryGpuState *secondary_gpu_state;
-  gboolean secondary_gpu_used;
 
   ClutterFrame *presented_frame;
-  ClutterFrame *posted_frame;
-  ClutterFrame *stalled_frame;
   ClutterFrame *next_frame;
 
   struct {
@@ -122,8 +119,6 @@
   } egl;
 #endif
 
-  gboolean needs_flush;
-
   gboolean frame_sync_requested;
   gboolean frame_sync_enabled;
 
@@ -145,13 +140,6 @@
 
 static GQuark blit_source_quark = 0;
 
-static void
-try_post_latest_swap (CoglOnscreen *onscreen);
-
-static void
-post_finish_frame (MetaOnscreenNative *onscreen_native,
-                   MetaKmsUpdate      *kms_update);
-
 static gboolean
 init_secondary_gpu_state (MetaRendererNative  *renderer_native,
                           CoglOnscreen        *onscreen,
@@ -162,20 +150,20 @@
 {
   MetaOnscreenNative *onscreen_native = META_ONSCREEN_NATIVE (onscreen);
 
-  if (!onscreen_native->posted_frame)
+  if (!onscreen_native->next_frame)
     return;
 
   g_clear_pointer (&onscreen_native->presented_frame, clutter_frame_unref);
   onscreen_native->presented_frame =
-    g_steal_pointer (&onscreen_native->posted_frame);
+    g_steal_pointer (&onscreen_native->next_frame);
 }
 
 static void
-meta_onscreen_native_clear_posted_fb (CoglOnscreen *onscreen)
+meta_onscreen_native_clear_next_fb (CoglOnscreen *onscreen)
 {
   MetaOnscreenNative *onscreen_native = META_ONSCREEN_NATIVE (onscreen);
 
-  g_clear_pointer (&onscreen_native->posted_frame, clutter_frame_unref);
+  g_clear_pointer (&onscreen_native->next_frame, clutter_frame_unref);
 }
 
 static void
@@ -213,7 +201,7 @@
 
   info = cogl_onscreen_pop_head_frame_info (onscreen);
 
-  g_return_if_fail (info);
+  g_assert (!cogl_onscreen_peek_head_frame_info (onscreen));
 
   _cogl_onscreen_notify_frame_sync (onscreen, info);
   _cogl_onscreen_notify_complete (onscreen, info);
@@ -238,13 +226,7 @@
 
   frame_info = cogl_onscreen_peek_head_frame_info (onscreen);
 
-  g_warn_if_fail (frame_info != NULL);
-  if (frame_info == NULL)
-    {
-      meta_onscreen_native_swap_drm_fb (onscreen);
-      try_post_latest_swap (onscreen);
-      return;
-    }
+  g_return_if_fail (frame_info != NULL);
 
   frame_counter = cogl_frame_info_get_frame_counter (frame_info);
 
@@ -261,7 +243,6 @@
 
   meta_onscreen_native_notify_frame_complete (onscreen);
   meta_onscreen_native_swap_drm_fb (onscreen);
-  try_post_latest_swap (onscreen);
 }
 
 static void
@@ -311,13 +292,15 @@
   CoglFramebuffer *framebuffer =
     clutter_stage_view_get_onscreen (CLUTTER_STAGE_VIEW (view));
   CoglOnscreen *onscreen = COGL_ONSCREEN (framebuffer);
+  MetaOnscreenNative *onscreen_native = META_ONSCREEN_NATIVE (onscreen);
   CoglFrameInfo *frame_info;
 
   frame_info = cogl_onscreen_peek_head_frame_info (onscreen);
   frame_info->flags |= COGL_FRAME_INFO_FLAG_SYMBOLIC;
 
+  g_warn_if_fail (!onscreen_native->next_frame);
+
   meta_onscreen_native_notify_frame_complete (onscreen);
-  try_post_latest_swap (onscreen);
 }
 
 static void
@@ -384,8 +367,7 @@
     }
 
   meta_onscreen_native_notify_frame_complete (onscreen);
-  meta_onscreen_native_clear_posted_fb (onscreen);
-  try_post_latest_swap (onscreen);
+  meta_onscreen_native_clear_next_fb (onscreen);
 }
 
 static const MetaKmsPageFlipListenerVtable page_flip_listener_vtable = {
@@ -446,34 +428,18 @@
 }
 #endif /* HAVE_EGL_DEVICE */
 
-static void
-drop_stalled_swap (CoglOnscreen *onscreen)
+void
+meta_onscreen_native_dummy_power_save_page_flip (CoglOnscreen *onscreen)
 {
   CoglFrameInfo *frame_info;
-  MetaOnscreenNative *onscreen_native = META_ONSCREEN_NATIVE (onscreen);
-
-  if (onscreen_native->stalled_frame == NULL)
-    return;
 
-  g_clear_pointer (&onscreen_native->stalled_frame, clutter_frame_unref);
+  meta_onscreen_native_swap_drm_fb (onscreen);
 
   frame_info = cogl_onscreen_peek_tail_frame_info (onscreen);
   frame_info->flags |= COGL_FRAME_INFO_FLAG_SYMBOLIC;
   meta_onscreen_native_notify_frame_complete (onscreen);
 }
 
-void
-meta_onscreen_native_dummy_power_save_page_flip (CoglOnscreen *onscreen)
-{
-  drop_stalled_swap (onscreen);
-
-  /* If the monitor just woke up and the shell is fully idle (has nothing
-   * more to swap) then we just woke to an indefinitely black screen. Let's
-   * fix that using the last swap (which is never classified as "stalled").
-   */
-  try_post_latest_swap (onscreen);
-}
-
 static void
 apply_transform (MetaCrtcKms            *crtc_kms,
                  MetaKmsPlaneAssignment *kms_plane_assignment,
@@ -578,7 +544,7 @@
 {
   MetaOnscreenNative *onscreen_native = META_ONSCREEN_NATIVE (onscreen);
   MetaRendererNative *renderer_native = onscreen_native->renderer_native;
-  g_autoptr (ClutterFrame) frame = NULL;
+  ClutterFrame *frame = onscreen_native->next_frame;
   MetaFrameNative *frame_native;
   MetaGpuKms *render_gpu = onscreen_native->render_gpu;
   MetaCrtcKms *crtc_kms = META_CRTC_KMS (crtc);
@@ -594,7 +560,6 @@
   COGL_TRACE_BEGIN_SCOPED (MetaOnscreenNativeFlipCrtcs,
                            "Meta::OnscreenNative::flip_crtc()");
 
-  frame = g_steal_pointer (&onscreen_native->next_frame);
   g_return_if_fail (frame);
 
   gpu_kms = META_GPU_KMS (meta_crtc_get_gpu (crtc));
@@ -657,10 +622,6 @@
 #endif
     }
 
-  g_warn_if_fail (!onscreen_native->posted_frame);
-  g_clear_pointer (&onscreen_native->posted_frame, clutter_frame_unref);
-  onscreen_native->posted_frame = g_steal_pointer (&frame);
-
   meta_kms_update_add_page_flip_listener (kms_update,
                                           kms_crtc,
                                           &page_flip_listener_vtable,
@@ -1046,17 +1007,12 @@
 secondary_gpu_get_next_dumb_buffer (MetaOnscreenNativeSecondaryGpuState *secondary_gpu_state)
 {
   MetaDrmBufferDumb *current_dumb_fb;
-  const int n_dumb_fbs = G_N_ELEMENTS (secondary_gpu_state->cpu.dumb_fbs);
-  int i;
 
   current_dumb_fb = secondary_gpu_state->cpu.current_dumb_fb;
-  for (i = 0; i < n_dumb_fbs; i++)
-    {
-      if (current_dumb_fb == secondary_gpu_state->cpu.dumb_fbs[i])
-        return secondary_gpu_state->cpu.dumb_fbs[(i + 1) % n_dumb_fbs];
-    }
-
-  return secondary_gpu_state->cpu.dumb_fbs[0];
+  if (current_dumb_fb == secondary_gpu_state->cpu.dumb_fbs[0])
+    return secondary_gpu_state->cpu.dumb_fbs[1];
+  else
+    return secondary_gpu_state->cpu.dumb_fbs[0];
 }
 
 static MetaDrmBuffer *
@@ -1395,34 +1351,10 @@
     g_warning ("Page flip failed: %s", error->message);
 
   frame_info = cogl_onscreen_peek_head_frame_info (onscreen);
+  frame_info->flags |= COGL_FRAME_INFO_FLAG_SYMBOLIC;
 
-  /* After resuming from suspend, drop_stalled_swap might have done this
-   * already and emptied the frame_info queue.
-   */
-  if (frame_info)
-    {
-      frame_info->flags |= COGL_FRAME_INFO_FLAG_SYMBOLIC;
-      meta_onscreen_native_notify_frame_complete (onscreen);
-    }
-
-  meta_onscreen_native_clear_posted_fb (onscreen);
-}
-
-static void
-assign_next_frame (MetaOnscreenNative *onscreen_native,
-                   ClutterFrame       *frame)
-{
-  CoglOnscreen *onscreen = COGL_ONSCREEN (onscreen_native);
-
-  if (onscreen_native->next_frame != NULL)
-    {
-      drop_stalled_swap (onscreen);
-      g_clear_pointer (&onscreen_native->stalled_frame, clutter_frame_unref);
-      onscreen_native->stalled_frame =
-        g_steal_pointer (&onscreen_native->next_frame);
-    }
-
-  onscreen_native->next_frame = clutter_frame_ref (frame);
+  meta_onscreen_native_notify_frame_complete (onscreen);
+  meta_onscreen_native_clear_next_fb (onscreen);
 }
 
 static const MetaKmsResultListenerVtable swap_buffer_result_listener_vtable = {
@@ -1442,41 +1374,53 @@
   CoglRendererEGL *cogl_renderer_egl = cogl_renderer->winsys;
   MetaRendererNativeGpuData *renderer_gpu_data = cogl_renderer_egl->platform;
   MetaRendererNative *renderer_native = renderer_gpu_data->renderer_native;
+  MetaRenderer *renderer = META_RENDERER (renderer_native);
+  MetaBackend *backend = meta_renderer_get_backend (renderer);
+  MetaMonitorManager *monitor_manager =
+    meta_backend_get_monitor_manager (backend);
   MetaOnscreenNative *onscreen_native = META_ONSCREEN_NATIVE (onscreen);
+  MetaOnscreenNativeSecondaryGpuState *secondary_gpu_state;
   MetaGpuKms *render_gpu = onscreen_native->render_gpu;
   MetaDeviceFile *render_device_file;
   ClutterFrame *frame = user_data;
   MetaFrameNative *frame_native = meta_frame_native_from_frame (frame);
+  MetaKmsUpdate *kms_update;
   CoglOnscreenClass *parent_class;
+  gboolean secondary_gpu_used = FALSE;
+  MetaPowerSave power_save_mode;
   g_autoptr (GError) error = NULL;
   MetaDrmBufferFlags buffer_flags;
   MetaDrmBufferGbm *buffer_gbm;
   g_autoptr (MetaDrmBuffer) primary_gpu_fb = NULL;
   g_autoptr (MetaDrmBuffer) secondary_gpu_fb = NULL;
   g_autoptr (MetaDrmBuffer) buffer = NULL;
+  MetaKmsCrtc *kms_crtc;
+  MetaKmsDevice *kms_device;
+
+  COGL_TRACE_SCOPED_ANCHOR (MetaRendererNativePostKmsUpdate);
 
   COGL_TRACE_BEGIN_SCOPED (MetaRendererNativeSwapBuffers,
                            "Meta::OnscreenNative::swap_buffers_with_damage()");
 
-  if (meta_is_topic_enabled (META_DEBUG_KMS))
-    {
-      unsigned int frames_pending =
-        cogl_onscreen_get_pending_frame_count (onscreen);
-
-      meta_topic (META_DEBUG_KMS,
-                  "Swap buffers: %u frames pending (%s-buffering)",
-                  frames_pending,
-                  frames_pending == 1 ? "double" :
-                  frames_pending == 2 ? "triple" :
-                  "?");
-    }
-
   secondary_gpu_fb =
     update_secondary_gpu_state_pre_swap_buffers (onscreen,
                                                  rectangles,
                                                  n_rectangles);
 
-  if (!onscreen_native->secondary_gpu_used)
+  secondary_gpu_state = onscreen_native->secondary_gpu_state;
+  if (secondary_gpu_state)
+    {
+      MetaRendererNativeGpuData *secondary_gpu_data;
+
+      secondary_gpu_data =
+        meta_renderer_native_get_gpu_data (renderer_native,
+                                           secondary_gpu_state->gpu_kms);
+      secondary_gpu_used =
+        secondary_gpu_data->secondary.copy_mode ==
+        META_SHARED_FRAMEBUFFER_COPY_MODE_SECONDARY_GPU;
+    }
+
+  if (!secondary_gpu_used)
     cogl_onscreen_egl_maybe_create_timestamp_query (onscreen, frame_info);
 
   parent_class = COGL_ONSCREEN_CLASS (meta_onscreen_native_parent_class);
@@ -1539,75 +1483,15 @@
 #endif
     }
 
-  assign_next_frame (onscreen_native, frame);
-
-  clutter_frame_set_result (frame,
-                            CLUTTER_FRAME_RESULT_PENDING_PRESENTED);
-
-  meta_frame_native_set_damage (frame_native, rectangles, n_rectangles);
-  try_post_latest_swap (onscreen);
-  return;
-
-swap_failed:
-  frame_info->flags |= COGL_FRAME_INFO_FLAG_SYMBOLIC;
-  meta_onscreen_native_notify_frame_complete (onscreen);
-  clutter_frame_set_result (frame, CLUTTER_FRAME_RESULT_IDLE);
-}
-
-static void
-try_post_latest_swap (CoglOnscreen *onscreen)
-{
-  CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
-  CoglContext *cogl_context = cogl_framebuffer_get_context (framebuffer);
-  CoglRenderer *cogl_renderer = cogl_context->display->renderer;
-  CoglRendererEGL *cogl_renderer_egl = cogl_renderer->winsys;
-  MetaRendererNativeGpuData *renderer_gpu_data = cogl_renderer_egl->platform;
-  MetaRendererNative *renderer_native = renderer_gpu_data->renderer_native;
-  MetaRenderer *renderer = META_RENDERER (renderer_native);
-  MetaBackend *backend = meta_renderer_get_backend (renderer);
-  MetaBackendNative *backend_native = META_BACKEND_NATIVE (backend);
-  MetaKms *kms = meta_backend_native_get_kms (backend_native);
-  MetaMonitorManager *monitor_manager =
-    meta_backend_get_monitor_manager (backend);
-  MetaOnscreenNative *onscreen_native = META_ONSCREEN_NATIVE (onscreen);
-  MetaPowerSave power_save_mode;
-  MetaCrtcKms *crtc_kms = META_CRTC_KMS (onscreen_native->crtc);
-  MetaKmsCrtc *kms_crtc = meta_crtc_kms_get_kms_crtc (crtc_kms);
-  MetaKmsDevice *kms_device = meta_kms_crtc_get_device (kms_crtc);
-  MetaKmsUpdate *kms_update;
-  g_autoptr (MetaKmsFeedback) kms_feedback = NULL;
-  g_autoptr (ClutterFrame) frame = NULL;
-  MetaFrameNative *frame_native;
-  COGL_TRACE_SCOPED_ANCHOR (MetaRendererNativePostKmsUpdate);
+  g_warn_if_fail (!onscreen_native->next_frame);
+  onscreen_native->next_frame = clutter_frame_ref (frame);
 
-  if (onscreen_native->next_frame == NULL ||
-      onscreen_native->posted_frame != NULL ||
-      onscreen_native->view == NULL ||
-      meta_kms_is_shutting_down (kms))
-    return;
+  kms_crtc = meta_crtc_kms_get_kms_crtc (META_CRTC_KMS (onscreen_native->crtc));
+  kms_device = meta_kms_crtc_get_device (kms_crtc);
 
   power_save_mode = meta_monitor_manager_get_power_save_mode (monitor_manager);
   if (power_save_mode == META_POWER_SAVE_ON)
     {
-      int n_rectangles;
-      int *rectangles;
-
-      frame = clutter_frame_ref (onscreen_native->next_frame);
-      frame_native = meta_frame_native_from_frame (frame);
-
-      if (renderer_gpu_data->mode == META_RENDERER_NATIVE_MODE_GBM &&
-          meta_frame_native_get_buffer (frame_native) == NULL)
-        {
-          kms_update = meta_frame_native_steal_kms_update (frame_native);
-          if (kms_update)
-            post_finish_frame (onscreen_native, kms_update);
-          return;
-        }
-
-      n_rectangles = meta_frame_native_get_damage (frame_native, &rectangles);
-
-      drop_stalled_swap (onscreen);
-
       kms_update = meta_frame_native_ensure_kms_update (frame_native,
                                                         kms_device);
       meta_kms_update_add_result_listener (kms_update,
@@ -1629,11 +1513,13 @@
     {
       meta_renderer_native_queue_power_save_page_flip (renderer_native,
                                                        onscreen);
+      clutter_frame_set_result (frame,
+                                CLUTTER_FRAME_RESULT_PENDING_PRESENTED);
       return;
     }
 
   COGL_TRACE_BEGIN_ANCHORED (MetaRendererNativePostKmsUpdate,
-                             "Meta::OnscreenNative::try_post_latest_swap#post_pending_update()");
+                             "Meta::OnscreenNative::swap_buffers_with_damage#post_pending_update()");
 
   switch (renderer_gpu_data->mode)
     {
@@ -1648,6 +1534,8 @@
           kms_update = meta_frame_native_steal_kms_update (frame_native);
           meta_renderer_native_queue_mode_set_update (renderer_native,
                                                       kms_update);
+          clutter_frame_set_result (frame,
+                                    CLUTTER_FRAME_RESULT_PENDING_PRESENTED);
           return;
         }
       else if (meta_renderer_native_has_pending_mode_set (renderer_native))
@@ -1661,6 +1549,8 @@
 
           meta_frame_native_steal_kms_update (frame_native);
           meta_renderer_native_post_mode_set_updates (renderer_native);
+          clutter_frame_set_result (frame,
+                                    CLUTTER_FRAME_RESULT_PENDING_PRESENTED);
           return;
         }
       break;
@@ -1676,6 +1566,8 @@
                                                       kms_update);
 
           meta_renderer_native_post_mode_set_updates (renderer_native);
+          clutter_frame_set_result (frame,
+                                    CLUTTER_FRAME_RESULT_PENDING_PRESENTED);
           return;
         }
       break;
@@ -1689,7 +1581,7 @@
 
   kms_update = meta_frame_native_steal_kms_update (frame_native);
 
-  if (!onscreen_native->secondary_gpu_used)
+  if (!secondary_gpu_used)
     {
       int sync_fd;
 
@@ -1699,6 +1591,13 @@
 
   meta_kms_device_post_update (kms_device, kms_update,
                                META_KMS_UPDATE_FLAG_NONE);
+  clutter_frame_set_result (frame, CLUTTER_FRAME_RESULT_PENDING_PRESENTED);
+  return;
+
+swap_failed:
+  frame_info->flags |= COGL_FRAME_INFO_FLAG_SYMBOLIC;
+  meta_onscreen_native_notify_frame_complete (onscreen);
+  clutter_frame_set_result (frame, CLUTTER_FRAME_RESULT_IDLE);
 }
 
 gboolean
@@ -1766,11 +1665,11 @@
                         G_IO_ERROR_PERMISSION_DENIED))
     {
       ClutterStageView *view = CLUTTER_STAGE_VIEW (onscreen_native->view);
-      ClutterFrame *posted_frame = onscreen_native->posted_frame;
-      MetaFrameNative *posted_frame_native =
-        meta_frame_native_from_frame (posted_frame);
+      ClutterFrame *next_frame = onscreen_native->next_frame;
+      MetaFrameNative *next_frame_native =
+        meta_frame_native_from_frame (next_frame);
       CoglScanout *scanout =
-        meta_frame_native_get_scanout (posted_frame_native);
+        meta_frame_native_get_scanout (next_frame_native);
 
       g_warning ("Direct scanout page flip failed: %s", error->message);
 
@@ -1783,7 +1682,7 @@
   frame_info->flags |= COGL_FRAME_INFO_FLAG_SYMBOLIC;
 
   meta_onscreen_native_notify_frame_complete (onscreen);
-  meta_onscreen_native_clear_posted_fb (onscreen);
+  meta_onscreen_native_clear_next_fb (onscreen);
 }
 
 static const MetaKmsResultListenerVtable scanout_result_listener_vtable = {
@@ -1835,24 +1734,13 @@
       return FALSE;
     }
 
-  /* Our direct scanout frame counts as 1, so more than that means we would
-   * be jumping the queue (and post would fail).
-   */
-  if (cogl_onscreen_get_pending_frame_count (onscreen) > 1)
-    {
-      g_set_error_literal (error,
-                           COGL_SCANOUT_ERROR,
-                           COGL_SCANOUT_ERROR_INHIBITED,
-                           "Direct scanout is inhibited during triple buffering");
-      return FALSE;
-    }
-
   renderer_gpu_data = meta_renderer_native_get_gpu_data (renderer_native,
                                                          render_gpu);
 
   g_warn_if_fail (renderer_gpu_data->mode == META_RENDERER_NATIVE_MODE_GBM);
 
-  assign_next_frame (onscreen_native, frame);
+  g_warn_if_fail (!onscreen_native->next_frame);
+  onscreen_native->next_frame = clutter_frame_ref (frame);
 
   meta_frame_native_set_scanout (frame_native, scanout);
   meta_frame_native_set_buffer (frame_native,
@@ -2100,74 +1988,21 @@
   MetaFrameNative *frame_native = meta_frame_native_from_frame (frame);
   MetaKmsUpdate *kms_update;
 
-  onscreen_native->needs_flush |= meta_kms_device_handle_flush (kms_device,
-                                                                kms_crtc);
-
-  if (!meta_frame_native_has_kms_update (frame_native))
+  kms_update = meta_frame_native_steal_kms_update (frame_native);
+  if (!kms_update)
     {
-      if (!onscreen_native->needs_flush ||
-          onscreen_native->posted_frame != NULL)
+      if (meta_kms_device_handle_flush (kms_device, kms_crtc))
+        {
+          kms_update = meta_kms_update_new (kms_device);
+          meta_kms_update_set_flushing (kms_update, kms_crtc);
+        }
+      else
         {
           clutter_frame_set_result (frame, CLUTTER_FRAME_RESULT_IDLE);
           return;
         }
     }
 
-  if (onscreen_native->posted_frame != NULL &&
-      onscreen_native->next_frame == NULL)
-    {
-      g_return_if_fail (meta_frame_native_has_kms_update (frame_native));
-      assign_next_frame (onscreen_native, frame);
-      clutter_frame_set_result (frame, CLUTTER_FRAME_RESULT_PENDING_PRESENTED);
-      return;
-    }
-
-  kms_update = meta_frame_native_steal_kms_update (frame_native);
-
-  if (onscreen_native->posted_frame != NULL &&
-      onscreen_native->next_frame != NULL)
-    {
-      MetaFrameNative *older_frame_native;
-      MetaKmsUpdate *older_kms_update;
-
-      g_return_if_fail (kms_update);
-
-      older_frame_native =
-        meta_frame_native_from_frame (onscreen_native->next_frame);
-      older_kms_update =
-        meta_frame_native_ensure_kms_update (older_frame_native, kms_device);
-      meta_kms_update_merge_from (older_kms_update, kms_update);
-      meta_kms_update_free (kms_update);
-      clutter_frame_set_result (frame, CLUTTER_FRAME_RESULT_IDLE);
-      return;
-    }
-
-  if (!kms_update)
-    {
-      kms_update = meta_kms_update_new (kms_device);
-      g_warn_if_fail (onscreen_native->needs_flush);
-    }
-
-  if (onscreen_native->needs_flush)
-    {
-      meta_kms_update_set_flushing (kms_update, kms_crtc);
-      onscreen_native->needs_flush = FALSE;
-    }
-
-  post_finish_frame (onscreen_native, kms_update);
-
-  clutter_frame_set_result (frame, CLUTTER_FRAME_RESULT_PENDING_PRESENTED);
-}
-
-static void
-post_finish_frame (MetaOnscreenNative *onscreen_native,
-                   MetaKmsUpdate      *kms_update)
-{
-  MetaCrtc *crtc = onscreen_native->crtc;
-  MetaKmsCrtc *kms_crtc = meta_crtc_kms_get_kms_crtc (META_CRTC_KMS (crtc));
-  MetaKmsDevice *kms_device = meta_kms_crtc_get_device (kms_crtc);
-  g_autoptr (MetaKmsFeedback) kms_feedback = NULL;
-
   meta_kms_update_add_result_listener (kms_update,
                                        &finish_frame_result_listener_vtable,
                                        NULL,
@@ -2190,15 +2025,7 @@
   meta_kms_update_set_flushing (kms_update, kms_crtc);
   meta_kms_device_post_update (kms_device, kms_update,
                                META_KMS_UPDATE_FLAG_NONE);
-}
-
-void
-meta_onscreen_native_discard_pending_swaps (CoglOnscreen *onscreen)
-{
-  MetaOnscreenNative *onscreen_native = META_ONSCREEN_NATIVE (onscreen);
-
-  g_clear_pointer (&onscreen_native->stalled_frame, clutter_frame_unref);
-  g_clear_pointer (&onscreen_native->next_frame, clutter_frame_unref);
+  clutter_frame_set_result (frame, CLUTTER_FRAME_RESULT_PENDING_PRESENTED);
 }
 
 static gboolean
@@ -2920,10 +2747,7 @@
                                                   onscreen,
                                                   renderer_gpu_data,
                                                   &local_error))
-        {
-          onscreen_native->secondary_gpu_used = TRUE;
-          return TRUE;
-        }
+        return TRUE;
 
       g_warning ("Secondary GPU initialization failed (%s). "
                  "Falling back to GPU-less mode instead, so the "
@@ -3107,8 +2931,6 @@
   meta_onscreen_native_detach (onscreen_native);
 
   g_clear_pointer (&onscreen_native->next_frame, clutter_frame_unref);
-  g_clear_pointer (&onscreen_native->stalled_frame, clutter_frame_unref);
-  g_clear_pointer (&onscreen_native->posted_frame, clutter_frame_unref);
   g_clear_pointer (&onscreen_native->presented_frame, clutter_frame_unref);
 
   renderer_gpu_data =
diff '--color=auto' -ur mutter-test/src/backends/native/meta-onscreen-native.h mutter-47.9/src/backends/native/meta-onscreen-native.h
--- mutter-test/src/backends/native/meta-onscreen-native.h	2025-07-21 18:02:06.611430874 +0800
+++ mutter-47.9/src/backends/native/meta-onscreen-native.h	2025-06-29 18:09:22.000000000 +0800
@@ -48,8 +48,6 @@
 gboolean meta_onscreen_native_is_buffer_scanout_compatible (CoglOnscreen *onscreen,
                                                             CoglScanout  *scanout);
 
-void meta_onscreen_native_discard_pending_swaps (CoglOnscreen *onscreen);
-
 void meta_onscreen_native_set_view (CoglOnscreen     *onscreen,
                                     MetaRendererView *view);
 
diff '--color=auto' -ur mutter-test/src/backends/native/meta-renderer-native.c mutter-47.9/src/backends/native/meta-renderer-native.c
--- mutter-test/src/backends/native/meta-renderer-native.c	2025-07-21 18:02:06.611430874 +0800
+++ mutter-47.9/src/backends/native/meta-renderer-native.c	2025-06-29 18:09:22.000000000 +0800
@@ -752,18 +752,12 @@
 dummy_power_save_page_flip_cb (gpointer user_data)
 {
   MetaRendererNative *renderer_native = user_data;
-  GList *old_list =
-    g_steal_pointer (&renderer_native->power_save_page_flip_onscreens);
 
-  g_list_foreach (old_list,
+  g_list_foreach (renderer_native->power_save_page_flip_onscreens,
                   (GFunc) meta_onscreen_native_dummy_power_save_page_flip,
                   NULL);
-  g_clear_list (&old_list,
+  g_clear_list (&renderer_native->power_save_page_flip_onscreens,
                 g_object_unref);
-
-  if (renderer_native->power_save_page_flip_onscreens != NULL)
-    return G_SOURCE_CONTINUE;
-
   renderer_native->power_save_page_flip_source_id = 0;
 
   return G_SOURCE_REMOVE;
@@ -775,9 +769,6 @@
 {
   const unsigned int timeout_ms = 100;
 
-  if (g_list_find (renderer_native->power_save_page_flip_onscreens, onscreen))
-    return;
-
   if (!renderer_native->power_save_page_flip_source_id)
     {
       renderer_native->power_save_page_flip_source_id =
@@ -1527,26 +1518,6 @@
 }
 
 static void
-discard_pending_swaps (MetaRenderer *renderer)
-{
-  GList *views = meta_renderer_get_views (renderer);;
-  GList *l;
-
-  for (l = views; l; l = l->next)
-    {
-      ClutterStageView *stage_view = l->data;
-      CoglFramebuffer *fb = clutter_stage_view_get_onscreen (stage_view);
-      CoglOnscreen *onscreen;
-
-      if (!COGL_IS_ONSCREEN (fb))
-        continue;
-
-      onscreen = COGL_ONSCREEN (fb);
-      meta_onscreen_native_discard_pending_swaps (onscreen);
-    }
-}
-
-static void
 meta_renderer_native_rebuild_views (MetaRenderer *renderer)
 {
   MetaRendererNative *renderer_native = META_RENDERER_NATIVE (renderer);
@@ -1556,7 +1527,6 @@
   MetaRendererClass *parent_renderer_class =
     META_RENDERER_CLASS (meta_renderer_native_parent_class);
 
-  discard_pending_swaps (renderer);
   meta_kms_discard_pending_page_flips (kms);
   g_hash_table_remove_all (renderer_native->mode_set_updates);
 
diff '--color=auto' -ur mutter-test/src/tests/native-kms-render.c mutter-47.9/src/tests/native-kms-render.c
--- mutter-test/src/tests/native-kms-render.c	2025-07-21 18:02:06.661431190 +0800
+++ mutter-47.9/src/tests/native-kms-render.c	2025-06-29 18:09:22.000000000 +0800
@@ -39,8 +39,6 @@
 #include "tests/meta-wayland-test-driver.h"
 #include "tests/meta-wayland-test-utils.h"
 
-#define N_FRAMES_PER_TEST 30
-
 typedef struct
 {
   int number_of_frames_left;
@@ -48,15 +46,12 @@
 
   struct {
     int n_paints;
-    int n_presentations;
-    int n_direct_scanouts;
-    GList *fb_ids;
+    uint32_t fb_id;
   } scanout;
 
   gboolean wait_for_scanout;
 
   struct {
-    int scanouts_attempted;
     gboolean scanout_sabotaged;
     gboolean fallback_painted;
     guint repaint_guard_id;
@@ -106,7 +101,7 @@
   gulong handler_id;
 
   test = (KmsRenderingTest) {
-    .number_of_frames_left = N_FRAMES_PER_TEST,
+    .number_of_frames_left = 10,
     .loop = g_main_loop_new (NULL, FALSE),
   };
   handler_id = g_signal_connect (stage, "after-update",
@@ -128,6 +123,7 @@
                           KmsRenderingTest *test)
 {
   test->scanout.n_paints = 0;
+  test->scanout.fb_id = 0;
 }
 
 static void
@@ -139,7 +135,6 @@
   CoglScanout *scanout;
   CoglScanoutBuffer *scanout_buffer;
   MetaDrmBuffer *buffer;
-  uint32_t fb_id;
 
   scanout = clutter_stage_view_peek_scanout (stage_view);
   if (!scanout)
@@ -148,13 +143,8 @@
   scanout_buffer = cogl_scanout_get_buffer (scanout);
   g_assert_true (META_IS_DRM_BUFFER (scanout_buffer));
   buffer = META_DRM_BUFFER (scanout_buffer);
-  fb_id = meta_drm_buffer_get_fb_id (buffer);
-  g_assert_cmpuint (fb_id, >, 0);
-  test->scanout.fb_ids = g_list_append (test->scanout.fb_ids,
-                                        GUINT_TO_POINTER (fb_id));
-
-  /* Triple buffering, but no higher */
-  g_assert_cmpuint (g_list_length (test->scanout.fb_ids), <=, 2);
+  test->scanout.fb_id = meta_drm_buffer_get_fb_id (buffer);
+  g_assert_cmpuint (test->scanout.fb_id, >, 0);
 }
 
 static void
@@ -183,12 +173,12 @@
   MetaDeviceFile *device_file;
   GError *error = NULL;
   drmModeCrtc *drm_crtc;
-  uint32_t first_fb_id_expected;
 
-  if (test->wait_for_scanout && test->scanout.fb_ids == NULL)
+  if (test->wait_for_scanout && test->scanout.n_paints > 0)
     return;
 
-  test->scanout.n_presentations++;
+  if (test->wait_for_scanout && test->scanout.fb_id == 0)
+    return;
 
   device_pool = meta_backend_native_get_device_pool (backend_native);
 
@@ -207,41 +197,15 @@
   drm_crtc = drmModeGetCrtc (meta_device_file_get_fd (device_file),
                              meta_kms_crtc_get_id (kms_crtc));
   g_assert_nonnull (drm_crtc);
-
-  if (test->scanout.fb_ids)
-    {
-      test->scanout.n_direct_scanouts++;
-      first_fb_id_expected = GPOINTER_TO_UINT (test->scanout.fb_ids->data);
-      test->scanout.fb_ids = g_list_delete_link (test->scanout.fb_ids,
-                                                 test->scanout.fb_ids);
-    }
+  if (test->scanout.fb_id == 0)
+    g_assert_cmpuint (drm_crtc->buffer_id, !=, test->scanout.fb_id);
   else
-    {
-      first_fb_id_expected = 0;
-    }
-
-  /* The buffer ID won't match on the first frame because switching from
-   * triple buffered compositing to double buffered direct scanout takes
-   * an extra frame to drain the queue. Thereafter we are in direct scanout
-   * mode and expect the buffer IDs to match.
-   */
-  if (test->scanout.n_presentations > 1)
-    {
-      if (first_fb_id_expected == 0)
-        g_assert_cmpuint (drm_crtc->buffer_id, !=, first_fb_id_expected);
-      else
-        g_assert_cmpuint (drm_crtc->buffer_id, ==, first_fb_id_expected);
-    }
-
+    g_assert_cmpuint (drm_crtc->buffer_id, ==, test->scanout.fb_id);
   drmModeFreeCrtc (drm_crtc);
 
   meta_device_file_release (device_file);
 
-  test->number_of_frames_left--;
-  if (test->number_of_frames_left <= 0)
-    g_main_loop_quit (test->loop);
-  else
-    clutter_actor_queue_redraw (CLUTTER_ACTOR (stage));
+  g_main_loop_quit (test->loop);
 }
 
 typedef enum
@@ -280,9 +244,7 @@
   g_assert_nonnull (wayland_test_client);
 
   test = (KmsRenderingTest) {
-    .number_of_frames_left = N_FRAMES_PER_TEST,
     .loop = g_main_loop_new (NULL, FALSE),
-    .scanout = {0},
     .wait_for_scanout = TRUE,
   };
 
@@ -308,8 +270,7 @@
   clutter_actor_queue_redraw (CLUTTER_ACTOR (stage));
   g_main_loop_run (test.loop);
 
-  g_assert_cmpint (test.scanout.n_presentations, ==, N_FRAMES_PER_TEST);
-  g_assert_cmpint (test.scanout.n_direct_scanouts, ==, N_FRAMES_PER_TEST);
+  g_assert_cmpuint (test.scanout.fb_id, >, 0);
 
   g_debug ("Unmake fullscreen");
   window = meta_find_window_from_title (test_context, "dma-buf-scanout-test");
@@ -331,15 +292,10 @@
   g_assert_cmpint (buffer_rect.y, ==, 10);
 
   test.wait_for_scanout = FALSE;
-  test.number_of_frames_left = N_FRAMES_PER_TEST;
-  test.scanout.n_presentations = 0;
-  test.scanout.n_direct_scanouts = 0;
-
   clutter_actor_queue_redraw (CLUTTER_ACTOR (stage));
   g_main_loop_run (test.loop);
 
-  g_assert_cmpint (test.scanout.n_presentations, ==, N_FRAMES_PER_TEST);
-  g_assert_cmpint (test.scanout.n_direct_scanouts, ==, 0);
+  g_assert_cmpuint (test.scanout.fb_id, ==, 0);
 
   g_debug ("Moving back to 0, 0");
   meta_window_move_frame (window, TRUE, 0, 0);
@@ -351,15 +307,10 @@
   g_assert_cmpint (buffer_rect.y, ==, 0);
 
   test.wait_for_scanout = TRUE;
-  test.number_of_frames_left = N_FRAMES_PER_TEST;
-  test.scanout.n_presentations = 0;
-  test.scanout.n_direct_scanouts = 0;
-
   clutter_actor_queue_redraw (CLUTTER_ACTOR (stage));
   g_main_loop_run (test.loop);
 
-  g_assert_cmpint (test.scanout.n_presentations, ==, N_FRAMES_PER_TEST);
-  g_assert_cmpint (test.scanout.n_direct_scanouts, ==, N_FRAMES_PER_TEST);
+  g_assert_cmpuint (test.scanout.fb_id, >, 0);
 
   g_signal_handler_disconnect (stage, before_update_handler_id);
   g_signal_handler_disconnect (stage, before_paint_handler_id);
@@ -413,15 +364,6 @@
   if (!scanout)
     return;
 
-  test->scanout_fallback.scanouts_attempted++;
-
-  /* The first scanout candidate frame will get composited due to triple
-   * buffering draining the queue to drop to double buffering. So don't
-   * sabotage that first frame.
-   */
-  if (test->scanout_fallback.scanouts_attempted < 2)
-    return;
-
   g_assert_false (test->scanout_fallback.scanout_sabotaged);
 
   if (is_atomic_mode_setting (kms_device))
@@ -459,15 +401,6 @@
       g_clear_handle_id (&test->scanout_fallback.repaint_guard_id,
                          g_source_remove);
       test->scanout_fallback.fallback_painted = TRUE;
-      test->scanout_fallback.scanout_sabotaged = FALSE;
-    }
-  else if (test->scanout_fallback.scanouts_attempted == 1)
-    {
-      /* Now that we've seen the first scanout attempt that was inhibited by
-       * triple buffering, try a second frame. The second one should scanout
-       * and will be sabotaged.
-       */
-      clutter_actor_queue_redraw (CLUTTER_ACTOR (stage));
     }
 }
 
@@ -477,11 +410,11 @@
                                ClutterFrameInfo *frame_info,
                                KmsRenderingTest *test)
 {
-  if (test->scanout_fallback.fallback_painted)
-    g_main_loop_quit (test->loop);
+  if (!test->scanout_fallback.scanout_sabotaged)
+    return;
 
-  test->number_of_frames_left--;
-  g_assert_cmpint (test->number_of_frames_left, >, 0);
+  g_assert_true (test->scanout_fallback.fallback_painted);
+  g_main_loop_quit (test->loop);
 }
 
 static void
@@ -510,7 +443,6 @@
   g_assert_nonnull (wayland_test_client);
 
   test = (KmsRenderingTest) {
-    .number_of_frames_left = N_FRAMES_PER_TEST,
     .loop = g_main_loop_new (NULL, FALSE),
   };
 
Only in mutter-47.9/subprojects: gvdb
